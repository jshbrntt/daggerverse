// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
	"go.opentelemetry.io/otel/trace"

	"main/internal/dagger"
	"main/internal/querybuilder"
	"main/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Utils) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *Utils) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
}

func dispatch(ctx context.Context) error {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return fmt.Errorf("invoke: %w", err)
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}
	if err = fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Utils":
		switch fnName {
		case "WithCommands":
			var parent Utils
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var c *dagger.Container
			if inputArgs["c"] != nil {
				err = json.Unmarshal([]byte(inputArgs["c"]), &c)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg c", err))
				}
			}
			var cmds [][]string
			if inputArgs["cmds"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cmds"]), &cmds)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cmds", err))
				}
			}
			return (*Utils).WithCommands(&parent, c, cmds)
		case "WithEnvVariables":
			var parent Utils
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var c *dagger.Container
			if inputArgs["c"] != nil {
				err = json.Unmarshal([]byte(inputArgs["c"]), &c)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg c", err))
				}
			}
			var envs *dagger.Secret
			if inputArgs["envs"] != nil {
				err = json.Unmarshal([]byte(inputArgs["envs"]), &envs)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg envs", err))
				}
			}
			return (*Utils).WithEnvVariables(&parent, ctx, c, envs), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithDescription("container utils module\n\nThis file contains the container utils module, which is a set of functions that\ncan be used to modify a container and enhance its functionality in different ways.\n").
			WithObject(
				dag.TypeDef().WithObject("Utils", dagger.TypeDefWithObjectOpts{SourceMap: dag.SourceMap("main.go", 15, 6)}).
					WithFunction(
						dag.Function("WithCommands",
							dag.TypeDef().WithObject("Container")).
							WithDescription("WithCommands takes a container and a slice of command arguments and returns a new container\nwith the specified commands. It generates a shell script based on the provided commands\nand sets it as the entrypoint for the container. The commands are executed when the container\nis started.\n\nIf the bash executable is not present, an error will be returned.\n\nParameters:\n  - c: The original container.\n  - cmds: A slice of command arguments. Each command is represented as a slice of strings.\n\nReturns:\n  - A new container with the specified commands.\n  - An error if the bash executable is not present.").
							WithSourceMap(dag.SourceMap("main.go", 53, 1)).
							WithArg("c", dag.TypeDef().WithObject("Container"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 53, 30)}).
							WithArg("cmds", dag.TypeDef().WithListOf(dag.TypeDef().WithListOf(dag.TypeDef().WithKind(dagger.TypeDefKindStringKind))), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 53, 51)})).
					WithFunction(
						dag.Function("WithEnvVariables",
							dag.TypeDef().WithObject("Container")).
							WithSourceMap(dag.SourceMap("main.go", 78, 1)).
							WithArg("c", dag.TypeDef().WithObject("Container"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 78, 55)}).
							WithArg("envs", dag.TypeDef().WithObject("Secret"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 78, 76)}))), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
